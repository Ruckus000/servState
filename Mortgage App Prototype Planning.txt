An Architectural Blueprint for a Cost-Effective Mortgage Servicing Web Prototype


This report details a complete strategic and technical plan for developing a working prototype of a mortgage servicing web application. The primary constraint guiding this analysis is the requirement to minimize cost ("without having to break the bank").
The plan is presented in five parts:
1. Functional Core Definition: An analysis of the essential Minimum Viable Product (MVP) features for both the borrower-facing portal and the administrative back-office.
2. Strategic Technology Stack: A recommendation for a specific set of tools, languages, and platforms engineered for rapid, low-cost prototyping.
3. Structural Framework: A detailed architectural diagram and database schema.
4. Implementation Roadmap: A step-by-step plan for building the prototype using the recommended stack.
5. Cost & Deployment Analysis: A guide to deploying the application for $0 and a clear, low-cost path for future scaling.


I. Defining the Prototype's Functional Core


To adhere to the primary cost constraint, a ruthless prioritization of features is necessary. The analysis of mortgage software functionality reveals a critical distinction between "Loan Origination Software" (LOS) and "Loan Servicing Software".
Loan origination involves complex, costly features such as automated underwriting, credit assessment, income verification, and compliance monitoring. To maintain a minimal budget and development timeline, this prototype will exclusively focus on loan servicing. The core assumption is that the loan has already been originated, and the prototype's function is to manage its lifecycle from the first payment to the last.
The prototype's functionality is therefore divided into two distinct components: the Borrower Self-Service Portal and the Administrative Dashboard.


A. The Borrower Self-Service Portal: Key Features (MVP)


This is the primary, client-facing component of the application. It must provide transparency and empower the borrower with the essential tools to manage their loan.
1. Secure User Authentication & Management
   * Functionality: This is a non-negotiable "table stakes" feature for any financial application. The prototype must provide a secure interface for user signup, login (email/password), and a self-service password reset mechanism.
   * Implementation: This functionality will be handled entirely by the chosen Backend-as-a-Service (BaaS) platform, eliminating the need to build a complex and vulnerable authentication system from scratch.
2. Borrower Dashboard (The "Landing Page")
   * Functionality: Upon successful authentication, the borrower must be presented with an immediate, clear summary of their loan's status. Modern borrowers expect this 24/7 digital access. The dashboard will display:
      * Current Loan Balance
      * Next Payment Amount Due
      * Next Payment Due Date
      * Escrow Account Balance (if applicable)
   * Data Source(s):.
3. Payment Processing (Simulated)
   * Functionality: This feature is the core of the "working prototype." It provides a simple, clear interface for a borrower to make a one-time payment. The interface will include an input field for the payment amount and a "Pay Now" button, which will lead to a simulated payment form.
   * Implementation: Processing real money involves significant legal, compliance, and financial overhead. To bypass this entirely, the prototype will integrate a "sandbox" environment from a major payment processor like Stripe or PayPal. This provides a highly realistic user flow for entering test card data without any real funds being transacted.1
4. Payment & Transaction History
   * Functionality: A simple, table-based view of all past transactions. This builds borrower trust and transparency by showing a clear ledger of payments made, fees assessed, or escrow disbursements.
   * Implementation: This will be a read-only list populated from the system's transactions table.
5. Document Center
   * Functionality: A secure area for borrowers to access important loan documents. For the MVP, this will be a read-only feature allowing borrowers to view and download:
      * Monthly Loan Statements
      * Annual Escrow Account Disclosures
      * Other important notices.
   * Data Source(s):.


B. The Administrative Dashboard: Core Servicing Features (MVP)


This is the "back-office" interface for the servicer (i.e., the prototype owner) to manage the system and validate the borrower-side functionality.
1. Portfolio Dashboard
   * Functionality: A high-level, aggregate view of all loans in the system. This dashboard provides a "control panel" view, displaying key metrics:
      * A searchable list of all borrowers and their associated loans.
      * Total outstanding principal across the entire portfolio.
      * A real-time list of recent transactions from all borrowers.
2. Transaction Ledger
   * Functionality: A global, centralized, and immutable log of all transactions from all borrowers. This is the master source of truth for the entire servicing system. Its primary purpose in the prototype is to allow the administrator to verify that payments submitted through the Borrower Portal are being recorded correctly.
3. Basic Loan/User Management
   * Functionality: The ability to perform basic CRUD (Create, Read, Update, Delete) operations on loans and borrowers. This is essential for populating the prototype with test data and managing the system.
      * View a specific borrower's detailed loan information.
      * Manually enter a payment (to simulate receiving a check or wire).
      * Upload a document (e.g., a new statement) to a specific borrower's account.
   * Scope: While production-grade admin portals offer complex workflow-building tools, this prototype's admin panel will be limited to these essential data management functions.


II. The Strategic Technology Stack for Rapid, Cost-Effective Prototyping


The "don't break the bank" requirement dictates every technological choice. This leads to a clear, modern, and highly cost-effective stack that prioritizes managed services with generous free tiers over a traditional, self-hosted infrastructure.


A. The Core Architectural Choice: Backend-as-a-Service (BaaS)


A Backend-as-a-Service (BaaS) platform is a pre-built "engine" that provides all the complex, server-side functionality—such as databases, user authentication, and file storage—as a managed service, accessible via APIs.
Adopting a BaaS architecture is the central strategic decision that makes this low-cost prototype possible.
1. Drastic Cost Reduction: The primary benefit. A BaaS platform provides an instant, production-grade backend with a free tier. This means $0 for server hosting, $0 for database management, and $0 for authentication infrastructure.
2. Extreme Speed-to-Market: BaaS platforms are designed for rapid MVP and prototype development. Secure user authentication, which can take weeks to build and secure correctly, can be implemented in a single afternoon using pre-built BaaS components.
3. Focus on Core Value: BaaS handles all the "plumbing" (server maintenance, scaling, security patching). This allows a developer to focus 100% of their limited time and resources on building the user-facing Borrower Portal and Admin Dashboard.
A traditional stack, such as a Python/Django backend on an AWS server with a separate managed database, would require building, configuring, deploying, and paying for three separate components. The BaaS model consolidates all three into a single, free service.


B. Recommended Stack: Next.js (React) + Supabase


This is the specific, recommended technology stack that delivers on the BaaS strategy.
1. Backend & Database: Supabase
   * What it is: Supabase is an open-source Backend-as-a-Service platform. It provides a full backend (PostgreSQL database, authentication, file storage, and serverless functions) in a single, managed platform.
   * Why Supabase over Firebase? This is the most critical architectural decision. Firebase is a popular BaaS, but it is built on a NoSQL database. Supabase is built on PostgreSQL.
      * A mortgage servicing application is deeply and fundamentally relational. A borrower HAS ONE loan. A loan HAS MANY payments. A loan HAS ONE escrow_account. This is the exact data model that a relational SQL database like PostgreSQL is designed to handle with perfect integrity.
      * Forcing this transactional, relational data into a NoSQL database (like Firebase's) would require complex, error-prone data denormalization and difficult querying.
      * Therefore, for a FinTech application, Supabase's PostgreSQL foundation is the architecturally superior choice.
   * Other Benefits: Supabase is open-source (preventing vendor lock-in) and offers an exceptionally generous free tier, including 50,000 monthly active users and a 500 MB database.
2. Frontend: Next.js (built on React)
   * What it is: Next.js is a leading open-source framework for building user interfaces with React.
   * Why Next.js?
      * Rapid Development Ecosystem: React is the most popular frontend library, providing a massive ecosystem of tools and support.
      * Seamless Supabase Integration: A large and growing number of official tutorials, libraries, and guides exist for building full-stack applications with Next.js and Supabase, which dramatically accelerates development.
      * Zero-Cost, One-Click Deployment: Vercel, the company behind Next.js, provides a best-in-class, free "Hobby" tier for hosting Next.js applications. A developer can deploy the prototype from a GitHub repository with a single command.
3. Rapid UI Construction: Component Library (e.g., MUI or Flowbite)
   * Functionality: To build the Borrower Portal and Admin Dashboard quickly, writing custom CSS is a waste of resources. A pre-built component library is essential.
   * Recommendation: Use a library like MUI (Material-UI) or Flowbite. Flowbite is built on the popular and modern Tailwind CSS framework.
   * Why? These libraries provide all the necessary components (buttons, forms, data tables, dashboard layouts) out of the box, allowing the developer to assemble a professional-looking, responsive UI in days, not weeks.


III. The Structural Framework: Database & System Architecture


This section provides the "structural framework" for the application, starting with the high-level system flow and followed by the core database schema.


A. High-Level System Architecture (The $0 Stack)


This architecture is designed with no custom backend server, which is the key to its low cost. The "backend" is a combination of the BaaS platform and serverless functions.
1. The User (Borrower or Admin) accesses the Next.js Frontend in their browser.
2. The Next.js Frontend application is served to them from Vercel (on its Free Hobby Tier).
3. When a user signs up or logs in, the Next.js app communicates directly with Supabase Auth. Supabase securely handles the authentication flow.
4. When a user views their dashboard, the Next.js app communicates directly with the Supabase Database (PostgreSQL) to fetch loan data. This connection is secured using Supabase's Row Level Security (RLS), which ensures a user can only read data that belongs to them.
5. When a user uploads a document, the Next.js app communicates directly with Supabase Storage.
6. When a user clicks "Pay Now," the frontend communicates with the Stripe Sandbox API to get a test payment token. Upon success, the frontend securely calls a Supabase Edge Function (a small, serverless function) to write the payment to the transactions table. This prevents the client from having direct write-access to sensitive financial tables.


B. Core Database Schema (PostgreSQL for Supabase)


This schema is the foundational blueprint for the prototype's database. It is synthesized from data models for banking and loan management.
A key implementation detail: Supabase's authentication service creates a table in a separate schema (auth.users) to store user credentials. The schema below includes a public profiles table, which is a standard practice for linking the auth.users table to the application's data (like a borrower).
Table: MVP Database Schema for Mortgage Servicing
* Purpose: This table provides the explicit, actionable database structure required to build the prototype. It is the "structural framework" requested by the user and is essential for implementing the features defined in Part I.
Table Name
	Column Name
	Data Type
	Notes
	profiles
	id
	UUID
	Primary Key. Foreign key to auth.users.id.
	

	borrower_id
	UUID
	Foreign key to borrowers.id.
	

	is_admin
	Boolean
	DEFAULT false. Used to differentiate user types.
	borrowers
	id
	UUID
	Primary Key. DEFAULT gen_random_uuid()
	

	first_name
	TEXT
	Borrower's first name.
	

	last_name
	TEXT
	Borrower's last name.
	

	email
	TEXT
	Borrower's contact email.
	

	created_at
	TIMESTAMPTZ
	DEFAULT now()
	loans
	id
	UUID
	Primary Key.
	

	borrower_id
	UUID
	Foreign key to borrowers.id.
	

	original_amount
	NUMERIC(12, 2)
	The principal loan amount (e.g., 300,000.00).
	

	current_balance
	NUMERIC(12, 2)
	The actual remaining balance.
	

	interest_rate
	NUMERIC(5, 3)
	Annual interest rate (e.g., 6.500).
	

	term_months
	SMALLINT
	Total loan term (e.g., 360 for 30 years).
	

	status
	TEXT
	e.g., 'Active', 'Paid Off', 'Delinquent'.
	

	origination_date
	DATE
	The start date of the loan.
	amortization_schedule
	id
	BIGSERIAL
	Primary Key.
	

	loan_id
	UUID
	Foreign key to loans.id.
	

	payment_number
	SMALLINT
	The month number (1, 2, 3... 360).
	

	payment_date
	DATE
	The date this payment is due.
	

	principal_payment
	NUMERIC(12, 2)
	The principal portion of the payment.
	

	interest_payment
	NUMERIC(12, 2)
	The interest portion of the payment.
	

	remaining_balance
	NUMERIC(12, 2)
	The balance after this payment.
	transactions
	id
	UUID
	Primary Key.
	

	loan_id
	UUID
	Foreign key to loans.id.
	

	transaction_date
	TIMESTAMPTZ
	DEFAULT now().
	

	amount
	NUMERIC(12, 2)
	The amount of the transaction.
	

	type
	TEXT
	e.g., 'Payment', 'Late Fee', 'Escrow Disbursement'.
	

	status
	TEXT
	e.g., 'Pending', 'Succeeded', 'Failed'.
	

	payment_gateway_id
	TEXT
	(Optional) The ID from Stripe (e.g., pi_...).
	escrow_accounts
	id
	UUID
	Primary Key.
	

	loan_id
	UUID
	Foreign key to loans.id.
	

	current_balance
	NUMERIC(10, 2)
	The balance held for taxes/insurance.
	

	monthly_payment
	NUMERIC(10, 2)
	The portion of borrower's PITI that goes to escrow.
	documents
	id
	UUID
	Primary Key.
	

	loan_id
	UUID
	Foreign key to loans.id.
	

	file_name
	TEXT
	The user-facing file name (e.g., "Jan 2025 Statement").
	

	storage_path
	TEXT
	The path to the file in Supabase Storage.
	

	uploaded_at
	TIMESTAMPTZ
	DEFAULT now().
	

IV. Prototype Implementation Roadmap


This section provides an actionable, phased guide to building the prototype.


A. Phase 1: Project Setup, Database & Authentication


1. Create Supabase Project: Go to the Supabase website, sign up, and create a new project. This will provision the database, auth, and storage. Save the Project URL and the anon (publishable) key.
2. Initialize Database: Navigate to the "SQL Editor" in the Supabase dashboard. Copy and paste the CREATE TABLE commands based on the schema in Part III.B and run them to create all the necessary tables.
3. Initialize Next.js App: On a local development machine, run the command npx create-next-app@latest my-mortgage-app.
4. Install Dependencies: cd into the new project directory and install the necessary Supabase libraries: npm install @supabase/supabase-js @supabase/auth-helpers-nextjs @supabase/auth-ui-react.
5. Implement Authentication: By using the @supabase/auth-ui-react library, a complete, secure, and styled login/signup form can be added to the application with just a few lines of code. Following the official Supabase tutorials, a developer can create a "protected route" for the Borrower Dashboard, which automatically redirects any unauthenticated user back to the login page. This completes the "Secure User Authentication" feature.


B. Phase 2: Implementing the Core Servicing Engine


This phase builds the "working" component of the prototype.
1. The Amortization Logic:
   * A common mistake is trying to write the complex mortgage amortization formula from scratch. This is unnecessary.
   * Action: Install a pre-built, tested npm package for this logic: npm install mortgage-js.
   * Implementation: The mortgage-js library provides a calculatePayment function that, when given the loan terms (principal, rate, months), can generate a full payment schedule.2
   * This calculation should be performed once when a loan is created in the Admin Dashboard. The application will then loop through the entire payment schedule and INSERT all 360 (for example) payment entries into the amortization_schedule table.
   * This pre-calculation is a critical optimization. When a borrower logs in, the app does not perform any complex math; it simply queries the amortization_schedule table for the next payment due. This is extremely fast and efficient.
2. Simulating Payments (The "Working" Component):
   * Action: Integrate the Stripe Sandbox for payment simulation.
   * Implementation Steps:
      1. Create a free Stripe developer account and get the "Test Mode" API keys.
      2. Install Stripe's React libraries: npm install @stripe/react-stripe-js @stripe/stripe-js.
      3. Follow a standard React/Stripe tutorial to build a payment form.
      4. During testing, the user will enter Stripe's universal test card number (e.g., 4242 4242 4242 4242).1
      5. The Stripe Sandbox will process this test card and return a "success" response without any money moving.
      6. Upon receiving this "success" token, the frontend application will call a secure Supabase Edge Function. This serverless function will execute the payment logic: create a new row in the transactions table and update the loans.current_balance.


C. Phase 3: Building the Borrower & Admin Interfaces


1. Install UI Library: npm install @mui/material @emotion/react @emotion/styled (for MUI) or npm install flowbite flowbite-react tailwindcss (for Flowbite).
2. Borrower Dashboard: Create a set of React components to fetch and display data.
   * Dashboard.jsx: Fetches and displays data from the loans and amortization_schedule tables for the logged-in user.
   * PaymentHistory.jsx: Fetches and displays a list from the transactions table.
   * Documents.jsx: Fetches and lists files from Supabase Storage.
3. Admin Dashboard: Create a separate set of components, protected by a security rule.
   * Security: Implement Supabase's Row Level Security (RLS) to ensure that only users with the profiles.is_admin = true flag can access the admin-level data.
   * PortfolioView.jsx: Fetches all data from the loans and borrowers tables.
   * TransactionLedger.jsx: Fetches all data from the transactions table.


V. The Cost-Free Deployment & Scaling Pathway


This final section provides the plan for hosting the application for $0 and outlines the clear, low-cost path to scale if the prototype is successful.


A. A Guide to Free-Tier Deployment


1. Deploy Frontend (Next.js) to Vercel:
   * Push the completed Next.js project to a GitHub repository.
   * Sign up for Vercel using the Hobby (Free) tier.
   * Connect the Vercel account to the GitHub repository. Vercel will auto-detect the Next.js app and deploy it.
   * In the Vercel project settings, add the Supabase Project URL and anon key as environment variables.
2. Deploy Backend (Supabase):
   * This step is already complete. Supabase is a cloud-native service that is "live" from the moment of creation. The application is already running on Supabase's generous free tier.
The result is a full-stack, globally available web application with a secure database, authentication, and file storage for a total cost of $0.00.


B. Analysis of Free Tier Limitations (The "Catch")


These free tiers are generous, but not infinite. Understanding their boundaries is essential.
Table: Free Tier Limitations Analysis
* Purpose: To transparently assess the prototype's boundaries. This analysis shows the limits are exceptionally high for a prototype, reinforcing the cost-effectiveness of the strategy.
Provider
	Service
	Free Tier Limit
	Implication for Prototype
	Supabase
	Database
	500 MB
	This is the primary bottleneck. 500MB is enough for thousands of loans and their schedules, but not millions. For a prototype, this is more than sufficient.
	

	Auth
	50,000 Monthly Active Users (MAUs)
	Extremely generous. This is a non-issue.
	

	Storage
	1 GB
	Plenty of space for thousands of PDF statements.
	

	Egress
	~2 GB/day
	Generous. A non-issue for a prototype.
	Vercel
	Bandwidth
	100 GB/month
	Extremely generous for a web app. A non-issue.
	

	Serverless Functions
	1 Million Invocations
	More than enough for processing simulated payments.
	Stripe
	Sandbox
	Unlimited & Free
	The sandbox environment is always free for testing.
	The only practical limit a developer is likely to encounter during development and initial testing is the Supabase 500MB database limit. This is still a vast amount of space for a prototype.


C. The Path from Prototype to Production


This prototype is not a dead end. The chosen technology stack provides a clear, predictable, and exceptionally low-cost "scaling ladder."
1. Step 1 (Database): When the application is ready for production and exceeds the 500MB limit, the developer can upgrade to the Supabase Pro Plan. This costs approximately $25/month and provides 8GB of database space, daily backups, and a 7-day log retention.
2. Step 2 (Hosting): If the application becomes highly successful and exceeds Vercel's 100GB/month of free bandwidth, the developer can upgrade to the Vercel Pro Plan, which is pay-as-you-go.
3. Step 3 (Payments): To go live, the developer simply switches the Stripe API keys from "Test Mode" to "Live Mode."
This plan allows the prototype to be built and tested for $0, and to be scaled into a production-ready application capable of handling thousands of users for as little as $25/month. This
is the definition of a cost-effective, "don't break the bank" solution.
Works cited
1. Sandboxes | Stripe Documentation, accessed November 14, 2025, https://docs.stripe.com/sandboxes
2. mortgage-js | Yarn, accessed November 14, 2025, https://classic.yarnpkg.com/en/package/mortgage-js